## 核心算法流程

### 1. 海选（3x3邻域搜索）：快速筛选候选邻居

- **目标**：高效缩小碰撞检测的搜索范围，仅关注标签L周围的局部区域。
- **步骤**：
  1. 计算标签L中心点所在的网格坐标 $(l_x, l_y)$.
  2. 以$(l_x, l_y)$为中心，确定其周围3x3共9个格子的坐标。
  3. 遍历这9个格子，从`grid`中收集所有对象，形成`candidate_neighbors`列表。

### 2. 预判（卡尔曼滤波预测）：洞察未来动向

- **目标**：预测窗口内所有对象在下一个时间步长后的空间位置。
- **步骤**：
  1. 遍历`candidate_neighbors`及标签L自身。
  2. 调用每个对象的卡尔曼滤波器`kf.predict()`，并传入上一帧的加速度作为控制输入u。
  3. 得到每个对象的未来预测坐标。

### 3. 决策（基于预测的碰撞检测）：判断未来风险

- **目标**：利用预测结果判断是否会发生碰撞，决定是否需要物理干预。
- **步骤**：
  1. 获取标签L的预测矩形边界。
  2. 遍历`candidate_neighbors`，获取每个邻居的预测边界（矩形或圆形）。
  3. 对L和每个N进行AABB几何重叠测试。
  4. 若有重叠，`apply_force=True`，否则为`False`。

### 4. 行动（条件触发的力导向）：执行精确干预

- **目标**：根据碰撞预测结果，决定物理力的计算方式。
- **步骤**：
  - 若`apply_force=True`（预测会碰撞）：
    - 调用`ForceCalculator`，计算全部5种力（两种排斥力、时间约束力、拉力、摩擦力），合成为`total_force`，主动修正标签轨迹。
  - 若`apply_force=False`（预测无碰撞）：
    - 只计算固有力（拉力和摩擦力），用于速度衰减和稳定。

### 5. 更新与学习（状态更新与滤波器校准）

- **目标**：完成本轮物理移动，并校准卡尔曼滤波器以提升预测能力。
- **步骤**：
  1. 根据`total_force`和牛顿第二定律（F=ma）计算加速度，更新速度和位置。
  2. 用新位置作为测量值，调用`kf.update()`校准滤波器。

---

## 主要模块说明

- **force_calculator.py**  
  负责计算标签与邻居之间的各种物理力，包括排斥力、吸引力、摩擦力和时间约束力。

- **generic_kalman_filter.py & models.py**  
  实现通用卡尔曼滤波器，对点和标签的二维运动状态进行预测与修正。

- **simulation.py**  
  管理仿真流程，实现上述五步算法逻辑，维护对象状态并驱动物理演化。

- **visualizer.py**  
  使用Matplotlib进行仿真可视化，支持生成GIF动画。

- **main.py**  
  项目入口，负责数据加载、仿真初始化与动画输出。

